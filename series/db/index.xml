<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DB on 江小凡的博客</title>
    <link>https://jxiaof.com/series/db/</link>
    <description>Recent content in DB on 江小凡的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Designed By Felix</copyright>
    <lastBuildDate>Thu, 17 Dec 2020 11:23:00 +0800</lastBuildDate><atom:link href="https://jxiaof.com/series/db/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Prometheus</title>
      <link>https://jxiaof.com/post/prometheus/</link>
      <pubDate>Thu, 17 Dec 2020 11:23:00 +0800</pubDate>
      
      <guid>https://jxiaof.com/post/prometheus/</guid>
      <description>0. 概述 ​	作为自动化监控指标,prometheus加上grafana已经是很好的一套组合.与此相似的还有ELKF架构.这两个都是不错的高完善度项目,两者目的和使用方式有一些区别,这里说说prometheus.其中prometheus的exproter用于生产待导入数据,这是关键的一步.
​	promrthus原本就有很多exproter,但是任务往往还需要自定义.这里我就结合近期,说说自定义采集数据到prometheus,之后通过grafana输出.
1. Flask 快速使用 如果是使用 Flask 的话，Promehteus 的 Python SDK 默认支持，可以这么用：
创建main.py
from flask import Flask from werkzeug.middleware.dispatcher import DispatcherMiddleware from prometheus_client import make_wsgi_app # Create my app app = Flask(__name__) # Add prometheus wsgi middleware to route /metrics requests app_dispatch = DispatcherMiddleware(app, { &amp;#39;/metrics&amp;#39;: make_wsgi_app() }) pip install uwsgi uwsgi --http 0.0.0.0:8000 --wsgi-file myapp.py --callable app_dispatch 这样就可以直接通过 wsgi 直接使用了：
curl -I http://localhost:8000/metrics 2. 单 Metric 实现 如果想要自己实现，那么也可以简单得实现：</description>
    </item>
    
    <item>
      <title>关于存储的笔记</title>
      <link>https://jxiaof.com/post/%E5%85%B3%E4%BA%8E%E5%AD%98%E5%82%A8/</link>
      <pubDate>Fri, 20 Nov 2020 02:26:39 +0800</pubDate>
      
      <guid>https://jxiaof.com/post/%E5%85%B3%E4%BA%8E%E5%AD%98%E5%82%A8/</guid>
      <description>存储系统科普——硬件层介绍
简介 该篇blog只是存储系列文章中的第一篇，所有文章请参考：
博客所有文章
在工程架构领域里，存储是一个非常重要的方向，这个方向从底至上，我分成了如下几个层次来介绍：
 硬件层：讲解磁盘，SSD，SAS, NAS, RAID等硬件层的基本原理，以及其为操作系统提供的存储界面； 操作系统层：即文件系统，操作系统如何将各个硬件管理并对上提供更高层次接口； 单机引擎层：常见存储系统对应单机引擎原理大概介绍，利用文件系统接口提供更高级别的存储系统接口； 分布式层：如何将多个单机引擎组合成一个分布式存储系统； 查询层：用户典型的查询语义表达以及解析；  主板结构 在进入对硬件层的分析前，让我们来看看电脑主板上各个原件之间的关系。
图1展示了主板上主要元件的结构图，以及他们之间的总线连接情况。核心连接点是北桥和南桥两块芯片。
其中北桥比较吊，连接的都是些高速设备。一般来说只连接CPU，内存和显卡几种设备。不过近些年也出现了PCIE2.0的高速接口接入北桥，使得一些符合标准的设备就可以接入北桥。
而南桥就相对搓了，他负责接入所有低速设备。什么USB，鼠标，磁盘，声卡等等都是接在南桥上的。而不同的设备用途和协议都有很大不同，所以设计了不同的交互协议。由于历史原因，不同设备传输介质可能都不一样，导致总线上布线十分复杂。所以到目前为止，主流设备都已经统一成为了PCI总线，大家一起用这条总线。
读写过程 我们来模拟一下CPU要从磁盘读入一份数据的过程：
  CPU发出一条指令说哥要准备读数据了
这条指令依次通过系统总线，桥间总线，PCI总线传递到了磁盘控制器。控制器收到指令了之后知道这是一次读请求，且读完了是否要发中断的信息。做好一些准备工作，等待读取数据。
  CPU再发出一条指令说要读取的逻辑地址
这条指令还是通过系列总线发给磁盘控制器之后。磁盘控制器就忙活了，查找逻辑快对应的物理块地址，查找，寻道等工作，就开始读取数据了。
  CPU再发出一条指令说读入内存的地址
当收到这条指令之后，CPU就不管了，他告诉一个叫DMA的总管，说接下来就靠你了。DMA设备会接管总线，负责将磁盘数据通过PCI总线，桥间总线，内存总线同步到内存指定位置。
  写操作的过程是类似的，就不累述了。
上面我们只是讲解了在主板上数据流转的过程，但是还有一个黑盒，就是磁盘控制器。这哥们到底是怎么管理的各个磁盘呢？在下一节我们将为你描述。
存储介质原理 上面讲了计算机读取数据的过程。这一章我们来大概说一下常见的存储介质的存储原理。
磁带 磁带就跟小时候听歌的时候的磁带类似。一条黑色带子上面有很多小的磁性粒子，根据粒子的南北级来判定0/1。
软盘 软盘比磁带要先进一点，记录数据的原理是一样的，只是可以随机读取，而磁带只能顺序读取。
硬盘 硬件原理 如果说前两个都是古老的东西，技术含量一般的话。硬盘就是一个很有技术含量的存储设备了，主要包含三大设备：
  电机
电机的目的是控制磁臂精准定位到磁道，一个磁道可能很小，要精准定位到哪个地方是高科技。
  盘面
盘面主要有两点。一点是基板要足够光滑平整，不能有任何瑕疵；一点是要将磁粉均匀的镀到基板上。这里有两个高科技，一个是磁粉的制造，一个是如何均匀的镀到基板上。
  磁头
磁头的主要难点是要控制好跟盘面的距离，跟软盘类似，硬盘也是通过修改磁粉的南北极来记录数据的。如果隔得太远，就感知不到磁性数据了，隔得太近呢，又可能把盘面刮到。当然0/1的表示并不是只有一个磁粉，而是一片区域的磁粉。
现在磁盘都是利用空气动力学，将磁头漂浮在盘面上面一点距离来控制磁头和盘面的距离。但是当硬盘停止工作不转的时候，磁头就肯定掉在盘面上了，所以一般盘面靠近圆心的地方一般都有一块没有磁粉的地方，用于安全停靠磁头。当硬盘要开始工作的时候，磁头在同心圆里面起飞，飞起来了之后再移动到其他地区。
不过我一直在想，是否可以有这样的技术，能在磁臂上装多个磁头，每个磁道对应一个，停止工作的时候就把磁臂固定在某个高度让他不挨着盘面，这样是不是能大大提高硬盘的读写效率，因为这样减少了寻道的时间。
  基本概念 硬盘组成原理图如下：
如上图, 硬盘主要有如下几个概念（概念比较简单，就不解释了）：
 扇区 磁道 柱面  读写过程 读写过程得分成两头来说，一头说将数据从各个盘面中读取出来；一头说如何将数据送给计算机。</description>
    </item>
    
    <item>
      <title>ClickHouse</title>
      <link>https://jxiaof.com/post/clickhouse/</link>
      <pubDate>Mon, 16 Nov 2020 17:44:29 +0800</pubDate>
      
      <guid>https://jxiaof.com/post/clickhouse/</guid>
      <description>ClickHouse是“战斗民族”俄罗斯搜索巨头Yandex公司开源的一个极具&amp;quot;战斗力&amp;quot;的实时数据分析数据库，是面向 OLAP 的分布式列式DBMS，圈内人戏称为“喀秋莎数据库”。ClickHouse有一个简称&amp;quot;CK&amp;quot;，与Hadoop、Spark这些巨无霸组件相比，ClickHouse很轻量级，其特点包括：分布式、列式存储、异步复制、线性扩展、支持数据压缩和最终数据一致性，其数据量级在PB级别。
LSM-Tree LSM-Tree全称是Log Structured Merge Tree，是一种分层，有序，面向磁盘的数据结构，其核心思想是充分利用磁盘,批量的顺序写要远比随机写性能高出很多
关于clickhouse Clickhouse 技能脑图 部署
实践
 携程日志系统
clickhouse性能对比
相关解读
深入理解什么是LSM-Tree</description>
    </item>
    
    <item>
      <title>Mongo</title>
      <link>https://jxiaof.com/post/mongo/</link>
      <pubDate>Thu, 15 Oct 2020 09:29:25 +0800</pubDate>
      
      <guid>https://jxiaof.com/post/mongo/</guid>
      <description>Document Database¶   High Performance
  Rich Query Language
  High Availability
  Support for Multiple Storage Engines
  Horizontal Scalability
   相关链接:
https://docs.mongodb.com/v3.6/reference/sql-comparison/
https://blog.csdn.net/luolian123456/article/details/83104242 /
https://www.cnblogs.com/leskang/p/6000852.html
 INSERT db.collection(&amp;#39;inventory&amp;#39;).insertMany([ // MongoDB adds the _id field with an ObjectId if _id is not present { item: &amp;#34;journal&amp;#34;, qty: 25, status: &amp;#34;A&amp;#34;, size: { h: 14, w: 21, uom: &amp;#34;cm&amp;#34; }, tags: [ &amp;#34;blank&amp;#34;, &amp;#34;red&amp;#34; ] }, { item: &amp;#34;notebook&amp;#34;, qty: 50, status: &amp;#34;A&amp;#34;, size: { h: 8.</description>
    </item>
    
    <item>
      <title>关于Redis的长期更新</title>
      <link>https://jxiaof.com/post/redis/</link>
      <pubDate>Wed, 14 Oct 2020 11:11:39 +0800</pubDate>
      
      <guid>https://jxiaof.com/post/redis/</guid>
      <description>redis redis数据类型分析 Redis的应用场景  高速缓存 - 将不常变化但又经常被访问的热点数据放到Redis数据库中，可以大大降低关系型数据库的压力，从而提升系统的响应性能。 排行榜 - 很多网站都有排行榜功能，利用Redis中的列表和有序集合可以非常方便的构造各种排行榜系统。 商品秒杀/投票点赞 - Redis提供了对计数操作的支持，网站上常见的秒杀、点赞等功能都可以利用Redis的计数器通过+1或-1的操作来实现，从而避免了使用关系型数据的update操作。 分布式锁 - 利用Redis可以跨多台服务器实现分布式锁（类似于线程锁，但是能够被多台机器上的多个线程或进程共享）的功能，用于实现一个阻塞式操作。 消息队列 - 消息队列和高速缓存一样，是一个大型网站不可缺少的基础服务，可以实现业务解耦和非实时业务削峰等特性  Redis的高并发和快速原因 1.redis是基于内存的，内存的读写速度非常快；
2.redis是单线程的，省去了很多上下文切换线程的时间；
3.redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。
为什么Redis是单线程的 1.官方答案
因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。
2.性能指标
关于redis的性能，轻松处理每秒几十万的请求。
3.详细原因
1）不需要各种锁的性能消耗
Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除
一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。
总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。
2）单线程多进程集群方案
单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。
所以单线程、多进程的集群不失为一个时髦的解决方案。
3）CPU消耗
采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。
但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？
可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。
Redis单线程的优劣势 单进程单线程优势
 代码更清晰，处理逻辑更简单 不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗 不存在多进程或者多线程导致的切换而消耗CPU  单进程单线程弊端
 无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；  IO多路复用技术 redis 采用网络IO多路复用技术来保证在多连接的时候， 系统的高吞吐量。
多路-指的是多个socket连接，复用-指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll, epoll是最新的也是目前最好的多路复用技术。
这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。
Redis高并发快总结  Redis是纯内存数据库，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快。 再说一下IO，Redis使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。 Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。 另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。 还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。   《Redis开发与运维》是一本不错的入门读物，而《Redis实战》是不错的进阶读物。</description>
    </item>
    
  </channel>
</rss>
