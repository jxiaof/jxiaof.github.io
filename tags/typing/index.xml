<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>typing on 江小凡的博客</title>
    <link>https://jxiaof.com/tags/typing/</link>
    <description>Recent content in typing on 江小凡的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Designed By Felix</copyright>
    <lastBuildDate>Fri, 23 Oct 2020 16:30:19 +0800</lastBuildDate><atom:link href="https://jxiaof.com/tags/typing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Python类型注解</title>
      <link>https://jxiaof.com/post/python%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Fri, 23 Oct 2020 16:30:19 +0800</pubDate>
      
      <guid>https://jxiaof.com/post/python%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3/</guid>
      <description>typing &amp;mdash; 类型标注支持 函数接受并返回一个字符串，注释像下面这样:
def greeting(name: str) -&amp;gt; str: return &amp;#39;Hello &amp;#39; + name 在函数 greeting 中，参数 name 预期是 str 类型，并且返回 str 类型。子类型允许作为参数。
类型别名 类型别名通过将类型分配给别名来定义。在这个例子中， Vector 和 List[float] 将被视为可互换的同义词:
from typing import List Vector = List[float] def scale(scalar: float, vector: Vector) -&amp;gt; Vector: return [scalar * num for num in vector] # typechecks; a list of floats qualifies as a Vector. new_vector = scale(2.0, [1.0, -4.2, 5.4]) 类型别名可用于简化复杂类型签名。例如:
from typing import Dict, Tuple, Sequence ConnectionOptions = Dict[str, str] Address = Tuple[str, int] Server = Tuple[Address, ConnectionOptions] def broadcast_message(message: str, servers: Sequence[Server]) -&amp;gt; None: .</description>
    </item>
    
  </channel>
</rss>
